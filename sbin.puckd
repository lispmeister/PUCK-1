#!/bin/bash -x

#
# Starts up the PUCK programs... openvpn, yate, and the node app
#
# Will create a default PUCK if none are present
#

echo starting PUCK server...

. /etc/puck/config.sh

cd $PUCK_HOME

# nuke any past status
echo '{"events":{"new_puck":""},"openvpn_server":{"vpn_status":"down","start":"n/a","start_s":"n/a","duration":"unknown","stop":"unknown","stop_s":"unknown", "client": "unknown", "client_pid":"unknown"},"openvpn_client":{"vpn_status":"down","start":"n/a","start_s":"n/a","duration":"unknown","stop":"unknown","stop_s":"unknown"}, "browser_events":{"127.0.0.1" :{ "notify_add":false, "notify_ring":false, "notify_file":false}}, "file_events": { "file_name" : "", "file_size" : "", "file_from" : ""}}' > $PUCK_HOME/status.puck

# clear server and client logs
echo > $PUCK_LOGS/client_vpn.log
echo > $PUCK_LOGS/server_vpn.log

# wipe out command logs
rm -f $PUCK_LOGS/*.err.log
rm -f $PUCK_LOGS/*.out.log

# if no dir or symlink
if [ ! -d $puck_keystore -o ! -h $puck_keystore ] ; then
    cd $hell
    ./rot-in-hell.sh

    cd ..

    mkdir $puck_keystore       2> /dev/null
    mkdir $keystore/vpn_client 2> /dev/null
    mkdir $PUCK_UPLOADS        2> /dev/null

    cp $hell/ca* $hell/puck* $puck_keystore

    ln -s $puck_keystore/ca.crt $puck_keystore/puckroot.crt

    cp $hell/vpn* $keystore/vpn_client

    # print SHA1 fingerprint
    openssl x509 -noout -fingerprint -in $puck_keystore/puck.crt | awk -F= '{print $2}' | sed 's/://g' | tee -a $puck_keystore/puck.pid

    pid=`cat $puck_keystore/puck.pid`
    cp $puck_keystore/puck.pid $PUCK_HOME/public/puck.pid

    # DHM key
    ./create_tlsauth.sh $pid

    # xxx - give all clients the same TA key?  No!

    ./create_dhm.sh

    mv $puck_keystore/* $keystore/$pid
    rmdir $puck_keystore
    ln -s $keystore/$pid $puck_keystore

    # print out some summary data about the keys
    for cert in $puck_keystore/{puck,ca}.crt $puck_keystore/vpn_client/vpn_client.crt ; do
        $PUCK_BIN/dump_cert.sh $cert > $cert.info
    done


    # current eth0 ip addr
    ip=$(ifconfig eth0 | awk '/inet/ {split($2, ip, ":"); print ip[2]}')

    # need to start this before we try a REST call to it....

#   NODE_PATH="/etc/puck/" node main.js &
    NODE_PATH="$PUCK_HOME/" node main.js &

    # try try again.... until... cant try no more
    # have to do this because it takes awhile for
    # the server to start up
    while test 1 = 1 ; do
        echo sleeping for 2 seconds
        sleep 2
        ./exe/create_puck.sh $pid img/puck.png $ip "$($PUCK_HOME/exe/get_net.sh)" Ms.PUCK puck@example.com
        if [ $? == 0 ] ; then
            break
        fi
    done

else
    cp $puck_keystore/puck.pid $PUCK_HOME/public/puck.pid

    # if not started above, do so now
    NODE_PATH="$PUCK_HOME/" node main.js &

fi

# for testing only... get something in the 10.x.y/24 zone
x=$((RANDOM%254+1))
y=$((RANDOM%254+1))

base10="10.$x.$y"

#
# why in the name of holy fuck does openvpn require a /29 or bigger?
# Did /31 kill their dog or something?  There must be a reason... somewhere...
#
mask10="255.255.255.248"

cd $PUCK_HOME

echo flushing all iptables and cached routes
./exe/flush.sh

openvpn --server $base10.0 $mask10 --config S.conf &

echo "$base10.1" > $PUCK_HOME/public/openvpn_server.ip

yate -c $PUCK_HOME/yate/ -vvvvv -d -l $PUCK_HOME/log/yate.log -Dt

# another... hack... in a long line of ... oh, forget it.
vpn_sleep=10
echo sleeping for $vpn_sleep seconds to try to ensure openvpn has an ip adddress up

sleep $vpn_sleep

vpn_ip=$(ifconfig | awk '{if (n) { all[dev] = substr($2, match($2, ":") + 1); n = 0 }} {if (match($0, "^[^ \t]") && $1 != "lo" && match($1, "^tun0$")) { n = 1; dev = $1; all[dev]="" }} END { for (i in all) print all[i]}'| sed 's/,]$/]/')

if [ "X$vpn_ip" = "X" ]; then
    echo "WARNING!  No IP picked up for OpenVPN"
    echo "WARNING!  No IP picked up for OpenVPN"
    echo "WARNING!  No IP picked up for OpenVPN"
    echo "WARNING!  No IP picked up for OpenVPN"
    echo "WARNING!  No IP picked up for OpenVPN"
else
    ./exe/forward_port.sh up 5555 $vpn_ip 12034 tcp
fi


exit 0

