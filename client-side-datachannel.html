
<div id="from-first-peer"> from first </div>
<div id="from-second-peer"> from second</div>

<div id="messages-sent-by-second-peer"> sent by second </div>
<div id="messages-sent-by-first-peer"> sent by first </div>


        <script>
            var answererDataChannel, offererDataChannel;
            var firstPeerTextBox = document.getElementById('from-first-peer');
            var secondPeerTextBox = document.getElementById('from-second-peer');

            var firstPeerOutput = document.getElementById('messages-sent-by-second-peer');
            var secondPeerOutput = document.getElementById('messages-sent-by-first-peer');

            HTMLElement.prototype.addLI = function (message) {
                var li = document.createElement('li');
                li.innerHTML = message;
                this.insertBefore(li, this.firstChild);
            };


            /* RTCDataChannel implementation for chrome */

            function RTCDataChannelForChrome() {
                var iceServers = {
                    iceServers: [{
                        url: 'stun:stun.l.google.com:19302'
                    }]
                };

                var optionalRtpDataChannels = {
                    optional: [{
                        RtpDataChannels: true
                    }]
                };

                var offerer = new webkitRTCPeerConnection(iceServers, optionalRtpDataChannels),
                    answerer;

                offererDataChannel = offerer.createDataChannel('RTCDataChannel', {
                    reliable: false
                });

                setChannelEvents(offererDataChannel, 'offerer');

                offerer.onicecandidate = function (event) {
                    if (!event || !event.candidate) return;
                    answerer && answerer.addIceCandidate(event.candidate);
                };

                var mediaConstraints = {
                    optional: [],
                    mandatory: {
                        OfferToReceiveAudio: false, // Hmm!!
                        OfferToReceiveVideo: false // Hmm!!
                    }
                };

                offerer.createOffer(function (sessionDescription) {
                    offerer.setLocalDescription(sessionDescription);
                    createAnswer(sessionDescription);
                }, null, mediaConstraints);


                function createAnswer(offerSDP) {
                    answerer = new webkitRTCPeerConnection(iceServers, optionalRtpDataChannels);
                    answererDataChannel = answerer.createDataChannel('RTCDataChannel', {
                        reliable: false
                    });

                    setChannelEvents(answererDataChannel, 'answerer');

                    answerer.onicecandidate = function (event) {
                        if (!event || !event.candidate) return;
                        offerer && offerer.addIceCandidate(event.candidate);
                    };

                    answerer.setRemoteDescription(offerSDP);
                    answerer.createAnswer(function (sessionDescription) {
                        answerer.setLocalDescription(sessionDescription);
                        offerer.setRemoteDescription(sessionDescription);
                    }, null, mediaConstraints);
                }

                function setChannelEvents(channel, channelNameForConsoleOutput) {
                    channel.onmessage = function (event) {
                        console.debug(channelNameForConsoleOutput, 'received a message:', event.data);

                        if (channelNameForConsoleOutput == 'offerer')
                            firstPeerOutput.addLI(event.data);
                        else
                            secondPeerOutput.addLI(event.data);
                    };

                    channel.onopen = function () {
                        channel.send('first text message over RTP data ports');
                        channel.send('bears fly wild!')
                    };
                }
            }


            /* RTCDataChannel implementation for Firefox */

            function RTCDataChannelForFirefox() {
                function setChannelEvents(channel, channelNameForConsoleOutput) {
                    channel.onmessage = function (event) {
                        console.debug(channelNameForConsoleOutput, 'received a message:', event.data);

                        if (channelNameForConsoleOutput == 'offerer')
                            firstPeerOutput.addLI(event.data);
                        else
                            secondPeerOutput.addLI(event.data);
                    };
                    channel.onopen = function () {
                        channel.send('first text message over SCTP data ports');
                    };
                }

                function useless() { }

                var iceServers = {
                    iceServers: [{
                        url: 'stun:23.21.150.121'
                    }]
                };

                var offerer = new mozRTCPeerConnection(iceServers), answerer;

                offererDataChannel = offerer.createDataChannel('channel', {});
                offererDataChannel.binaryType = 'blob';
                setChannelEvents(offererDataChannel, 'offerer');

                navigator.mozGetUserMedia({
                    audio: true,
                    fake: true
                }, function (stream) {
                    offerer.addStream(stream);

                    offerer.createOffer(function (sessionDescription) {
                        offerer.setLocalDescription(sessionDescription);
                        createAnswer(sessionDescription);
                    }, null, mediaConstraints);

                }, useless);

                var mediaConstraints = {
                    optional: [],
                    mandatory: {
                        OfferToReceiveAudio: true,
                        OfferToReceiveVideo: true
                    }
                };

                function createAnswer(offerSDP) {
                    answerer = new mozRTCPeerConnection(iceServers);
                    answerer.ondatachannel = function (event) {
                        answererDataChannel = event.channel;
                        answererDataChannel.binaryType = 'blob';
                        setChannelEvents(answererDataChannel, 'answerer');
                    };

                    navigator.mozGetUserMedia({
                        audio: true,
                        fake: true
                    }, function (stream) {

                        answerer.addStream(stream);
                        answerer.setRemoteDescription(offerSDP);

                        answerer.createAnswer(function (sessionDescription) {
                            answerer.setLocalDescription(sessionDescription);

                            offerer.setRemoteDescription(sessionDescription);
                        }, null, mediaConstraints);

                    }, useless);
                }
            }


            var isFirefox = !!navigator.mozGetUserMedia;

            if (isFirefox) RTCDataChannelForFirefox();
            else RTCDataChannelForChrome();

//          offererDataChannel.send('boobies');
//          answererDataChannel.send('titties');

        </script>


